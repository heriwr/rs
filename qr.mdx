Ownership, Borrowing, and Lifetimes

Copy Types: Types with a fixed size known at compile time that are implicitly copied when assigned or passed as arguments. Examples: integers, booleans, char.
RAII (Resource Acquisition is Initialization): A programming idiom where resources are tied to the lifetime of objects. Resource cleanup happens automatically when objects go out of scope.
References: Non-owning pointers to values. Denoted by &. Comes in two flavors:
Shared References (&T): Allow multiple read-only accesses.
Mutable References (&mut T): Allow a single, exclusive access for modification.
Lifetime Specifiers: Used to tell the compiler the relationships between references to ensure memory safety at compile time. Denoted by 'a, 'b, etc.
Data Types and Structures

Primitive Types: Basic built-in types like integers (i32, u64), floating-point numbers (f32, f64), Booleans (bool), and characters (char).
Tuple: A fixed-size collection of values that can be of different types.
Struct: A custom data type that groups related fields together.
Enum: A data type with a fixed set of possible variants.
Option (Option<T>): An enum used to represent the presence (Some(T)) or absence (None) of a value.
Result (Result<T, E>): An enum used for error handling, representing either successful computation (Ok(T)) or an error (Err(E)).
Control Flow

if/else if/else: Conditional branching.
match: Pattern matching for flexible control flow based on the shape of data.
loop: Unconditional, infinite loop.
while: Loop that executes as long as a condition is true.
for: Loop used for iterating over sequences (like arrays, vectors, ranges).
Functions and Modules

Closures: Anonymous functions that capture variables from their environment.
Higher-Order Functions: Functions that take other functions as arguments or return functions.
impl blocks: Used to define methods (functions associated with a struct, enum, or trait)
Modules: Used to organize code into logical units and control visibility. Denoted by the mod keyword.
use statement: Brings external code elements (modules, functions, types, etc.) into scope.
Collections

Vector (Vec<T>): A dynamically resizable array.
HashMap (HashMap<K, V>): A key-value data structure providing fast lookups by key.
BTreeMap (BTreeMap<K, V>): A sorted key-value map, where keys are kept in order.
String: A growable, UTF-8 encoded text data type.
&str (string slice): A reference to a portion of a String.
Concurrency

Threads: Independent units of execution within a process.
Channels: Mechanisms for communication and synchronization between threads (using std::sync::mpsc).
Mutex (std::sync::Mutex): Provides exclusive, mutable access to shared data across threads.
Advanced Concepts

Generics: Allow writing code that works with multiple types.
Macros: Metaprogramming facilities to extend the syntax of Rust.
Unsafe Rust: Code blocks within which some of Rust's usual guarantees can be relaxed for performance or low-level control. 

# Quick Reference

## Glossary

* Borrowing: Temporarily taking a reference to a value without taking ownership.
* Cargo: Rust's build system and package manager.
* crate: A module or a library in Rust.
* Lifetime: A mechanism that ensures references remain valid and prevents dangling pointers.
* Move: Transferring ownership of a value.
* Ownership: The principle that a value in Rust can only have one owner at a time.
* Trait: A definition of shared behaviour that types can implement.

## Symbols

| Symbol | Explanation                                                  | Example                                                        |
| ------ | ------------------------------------------------------------ | -------------------------------------------------------------- |
| `%`    | Modulo operator (computes the remainder of a division)       | `let remainder = 17 % 5; // remainder will be 2`              |
| `@`    | Used in `match` patterns for binding values and adding guards | `match x @ 0..=10 if x % 2 == 0 => {}`                        |
| `+`    | Addition or string concatenation                             | `let sum = 5 + 3;`                                             |
| `-`    | Subtraction or negation                                      | `let difference = 10 - 4;`                                     |
| `*`    | Multiplication                                               | `let product = 6 * 7;`                                          |
| `/`    | Division                                                     | `let quotient = 20 / 4;`                                        |
| `&`    | Bitwise AND or borrow a reference                            | `let x = 5 & 3;` <br/> `let ref_y = &y; `                    |
| `|`    | Bitwise OR or inclusive range pattern                        | `let x = 5 | 3;` <br/> `match x { 1..=10 => {} }`              |
| `^`    | Bitwise XOR                                                  | `let x = 5 ^ 3;`                                               |
| `!`    | Logical NOT or macro invocation                              | `let x = !true;` <br/> `println!("Hello {}", name!());`         |
| `==`   | Equality comparison                                          | `if x == 5 {}`                                                 |
| `!=`   | Inequality comparison                                        | `if y != 10 {}`                                                |
| `<`    | Less than comparison                                         | `if z < 20 {}`                                                 |
| `>`    | Greater than comparison                                      | `if w > 0 {}`                                                  |
| `<=`   | Less than or equal to comparison                             | `if v <= 100 {}`                                               |
| `>=`   | Greater than or equal to comparison                          | `if u >= 5 {}`                                                 |
| `=`    | Assignment                                                   | `let a = 10;`                                                  |
| `+=`   | Addition assignment                                          | `let mut b = 5; b += 3;`                                       |
| `-=`   | Subtraction assignment                                       | `let mut c = 8; c -= 2;`                                       |
| `*=`   | Multiplication assignment                                    | `let mut d = 2; d *= 5;`                                       |
| `/=`   | Division assignment                                          | `let mut e = 10; e /= 2;`                                      |
| `.`    | Access struct/enum members or call methods                   | `person.name` <br/> `my_vec.push(5);`                         | 
| `..`   | Exclusive range pattern                                      | `match x { 1..5 => {} }`                                       |
| `..=`  | Inclusive range pattern                                      | `match y { 1..=10 => {} }`                                     | 


## Syntax Basics

### Variables

``` let x = 5;        // Immutable variable
let mut y = 10;   // Mutable variable
``` 


### Functions:

```fn add(x: i32, y: i32) -> i32 {
    x + y
}
```

### Structs:

```struct Point {
    x: i32,
    y: i32,
}
```

### Enums:

```enum Color {
    Red,
    Green,
    Blue,
}
```

## Control Flow

### if/else:

```if x > 10 {
   // ...
} else {
   // ...
}
```

### Loops:

```for i in 0..10 {  // Range loop
    // ...   
}

let mut x = 5;
while x > 0 {     // Conditional loop
    // ...
    x -= 1;
}
```

## Ownership and Borrowing

```let s1 = String::from("hello"); 
let s2 = s1;  // Ownership of 's1' moved to 's2', 's1' is no longer usable

fn calculate_length(s: &String) -> usize { // Borrowing using reference (&)
    s.len()
} 
```
## Collections

### Vectors:

```let mut v = vec![1, 2, 3];  
v.push(4);
```

### HashMap:

```use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert("Alice", 10);
```

## Traits

```trait Printable {
    fn print(&self);
}

struct Book { /* ... */ }

impl Printable for Book {
    fn print(&self) {
        println!("Book details..."); 
    }
}
```

# Useful Resources

The Rust Book: (https://doc.rust-lang.org/book/)
Rust By Example: (https://doc.rust-lang.org/rust-by-example/)
Rust Playground: (https://play.rust-lang.org/)

Rust Atomics and Locks: (https://marabos.nl/atomics/foreword.html)